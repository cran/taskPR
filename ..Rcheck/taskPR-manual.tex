\documentclass{article}
\usepackage[ae,hyper]{Rd}
\begin{document}
\HeaderA{StartWorker}{Start Parallel-R Worker Process}{StartWorker}
\keyword{programming}{StartWorker}
\begin{Description}\relax
Attempts to connect to the given host and establish itself as a worker
process.  This function is called automatically when worker processes
are spawned by the main process.
\end{Description}
\begin{Usage}
\begin{verbatim}
StartWorker(host = "localhost", port=32000, retries=2, sleeptime=1, quiet=TRUE)
\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{host}] name of the machine that the main/controller process is on 
\item[\code{port}] the (TCP/IP) port number to connect to 
\item[\code{retries}] the number of times to retry making the connection 
\item[\code{sleeptime}] how long (in seconds) to sleep between connection tries 
\item[\code{quiet}] should the worker process supress most logging messages? 
\end{ldescription}
\end{Arguments}
\begin{Details}\relax
The only time a user should call this function is when they started the
parallel engine on the main process using the spawn=FALSE option to
StartPE.  In that case, the main process will block waiting for the
worker processes to connect.  The user must run the appropriate number
of worker processes and have them call this function.
\end{Details}
\begin{SeeAlso}\relax
\code{\LinkA{StartPE}{StartPE}}  For enabling the parallel engine.
\code{\LinkA{PE}{PE}}        For running parallel jobs.
\code{\LinkA{POBJ}{POBJ}}  For returning background jobs to the main process.
\end{SeeAlso}
\begin{Examples}
\begin{ExampleCode}
## Not run: 
# If you have MPI running
StartPE(2)

x = matrix(rnorm(128 * 128), 128, 128)

PE( a <- svd(x) )
PE( b <- solve(x) )
PE( y <- b %*% a$u )
POBJ( y )
str(y)
StopPE()
## End(Not run)
\end{ExampleCode}
\end{Examples}

\HeaderA{POBJ}{Parallel Object (Return a Parallel Objection to R's workspace)}{POBJ}
\keyword{programming}{POBJ}
\begin{Description}\relax
Blocks and waits for the specified variable to be returned by the
parallel engine.
\end{Description}
\begin{Usage}
\begin{verbatim}
POBJ(x)
\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] variable to return. 
\end{ldescription}
\end{Arguments}
\begin{Details}\relax
Because the \code{\LinkA{PE}{PE}} function executes jobs in the background,
there must be a way to return jobs to the foreground - to R's workspace.
That method is the POBJ function.  When passed a variable (which doesn't
have to exist in R's workspace, yet), the POBJ function waits until that
variable is available and returned from the parallel engine.
If variable to return is given as NULL, then the POBJ function waits for
all variables to be returned.
The POBJ function returns the \bold{symbol} of the variable, not the
variable itself.
\end{Details}
\begin{SeeAlso}\relax
\code{\LinkA{StartPE}{StartPE}}  For enabling the parallel engine.
\code{\LinkA{PE}{PE}}  For executing jobs in parallel.
\end{SeeAlso}
\begin{Examples}
\begin{ExampleCode}
## Not run: 
# If you have MPI running
StartPE(2)

x = matrix(rnorm(128 * 128), 128, 128)

PE( a <- svd(x) )
PE( b <- solve(x) )
PE( y <- b %*% a$u )
POBJ( y )
str(y)
StopPE()
## End(Not run)
\end{ExampleCode}
\end{Examples}

\HeaderA{PE}{Parallel Execute}{PE}
\keyword{programming}{PE}
\begin{Description}\relax
Attempts to execute the given expression through the parallel engine.
\end{Description}
\begin{Usage}
\begin{verbatim}
PE(x, global=FALSE)
\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] expression to execute in background/parallel 
\item[\code{global}] should this command be executed globally? 
\end{ldescription}
\end{Arguments}
\begin{Details}\relax
The parallel engine takes the given expression and tries to execute it
on a worker process (which may be on a remote system).  It will be
executed in the background and possibly in parallel with other PE calls.

Only a limited number of jobs can be run through the parallel engine at
once.  If that number is exceeded, then the PE call will block until some
of the jobs have finished.

\emph{The given expression \strong{must} be of the form "out <- f(...)".}

When code{global} is true, the command is executed globally.  This does
several things.  First, the parallel engine will wait until all workers
are free before started to execute the command.  Second, the command will
be executed on all worker processes simultaneously.  Third, the output of
the command will NOT be deleted from the worker processes' workspaces (as
is usually done).  This "global execute" functionality is designed for
loading libraries or defining functions, and not for the parallel
execution of common commands.
\end{Details}
\begin{SeeAlso}\relax
\code{\LinkA{StartPE}{StartPE}}  For enabling the parallel engine.
\code{\LinkA{POBJ}{POBJ}}  For returning background jobs to the main process.
\end{SeeAlso}
\begin{Examples}
\begin{ExampleCode}
## Not run: 
# If you have MPI running
StartPE(2)

x = matrix(rnorm(128 * 128), 128, 128)

PE( a <- svd(x) )
PE( b <- solve(x) )
PE( y <- b %*% a$u )
POBJ( y )
str(y)
StopPE()
## End(Not run)
\end{ExampleCode}
\end{Examples}

\HeaderA{StartPE}{Start/Stop Parallel Execution}{StartPE}
\aliasA{ParallelR}{StartPE}{ParallelR}
\aliasA{StopPE}{StartPE}{StopPE}
\aliasA{taskPR}{StartPE}{taskPR}
\keyword{programming}{StartPE}
\begin{Description}\relax
StartPE starts the parallel engine.  If spawn is true, then the worker
processes are spawned (using \code{MPI\_COMM\_Spawn} from MPI-2).
StopPE stops the parallel engine.  This call blocks until all jobs
are finished.
\end{Description}
\begin{Usage}
\begin{verbatim}
StartPE(num = 2, port = 32000, verbose=0, spawn=TRUE)
StopPE()
\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{num}] number of worker processes to use 
\item[\code{port}] the TCP port to use for communicating with workers 
\item[\code{verbose}] the verbose level: 0, 1, or 2 at the moment 
\item[\code{spawn}] should the worker processes be spawned? 
\end{ldescription}
\end{Arguments}
\begin{Details}\relax
The parallel engine must be enabled before instructions can be executed
in parallel.  The engine can be stopped and restarted with a different
number of worker processes, if desired.
The parallel engine consists of \code{num} + 1 threads and \code{num}
worker processes.  The worker processes can either be spawned (done
through an MPI call) or connected manually.  If StartPE is run with
spawn = FALSE, then it will block until \code{num} worker processes
have connected.
\end{Details}
\begin{SeeAlso}\relax
\code{\LinkA{PE}{PE}}  For executing jobs in the background/parallel.
\code{\LinkA{POBJ}{POBJ}}  For returning background/parallel jobs to the main process.
\code{\LinkA{StartWorker}{StartWorker}}  For manually starting worker processes.
\end{SeeAlso}
\begin{Examples}
\begin{ExampleCode}
## Not run: 
# If you have MPI running
StartPE(2)

x = matrix(rnorm(128 * 128), 128, 128)

PE( a <- svd(x) )
PE( b <- solve(x) )
PE( y <- b %*% a$u )
POBJ( y )
str(y)
StopPE()
## End(Not run)
\end{ExampleCode}
\end{Examples}

\end{document}
